---
name: CI
permissions:
  contents: read

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  # Allow manual triggering
  workflow_dispatch: {}

# Cancel in-progress runs on new pushes
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Parallel job structure for faster CI:
  # 1. determine-affected: Determines what packages are affected (runs first)
  # 2. setup-environment: Sets up the environment and caches (runs in parallel with determine-affected)
  # 3. lint, type-check, test: Run in parallel after setup (depend on both determine-affected and setup-environment)
  # 4. yaml-lint: Runs in parallel if YAML files changed (only depends on determine-affected)
  # 5. build: Runs after all validation jobs pass

  determine-affected:
    name: Determine Affected Packages
    runs-on: ubuntu-latest
    outputs:
      affected: ${{ steps.affected.outputs.affected }}
      yaml-changed: ${{ steps.yaml-changes.outputs.yaml-changed }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          install-dependencies: false

      - name: Make scripts executable
        run: chmod +x .github/scripts/get-affected-packages.sh

      - name: Determine affected packages
        id: affected
        run: |
          echo "::group::Affected Package Detection"

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "Pull request detected"
            # Use merge-base to find the common ancestor
            BASE_SHA=$(git merge-base ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
          else
            # For push to main, consider all packages affected
            if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
              echo "Push to main detected, considering all packages affected"
              echo "affected=all" >> $GITHUB_OUTPUT
              echo "Affected packages: all"
              echo "::endgroup::"
              exit 0
            fi

            # For other branches, use the previous commit
            BASE_SHA="HEAD~1"
          fi

          # Run the enhanced detection script
          echo "Running enhanced affected package detection..."
          # Capture only stdout in AFFECTED_PACKAGES, stderr will go to the logs
          AFFECTED_PACKAGES=$(.github/scripts/get-affected-packages.sh "$BASE_SHA")

          # Log the result without any formatting that could confuse GitHub Actions
          echo "Script returned: $AFFECTED_PACKAGES"

          # If no packages found or empty result, set to empty string
          if [[ -z "$AFFECTED_PACKAGES" ]]; then
            echo "No affected packages found"
          elif [[ "$AFFECTED_PACKAGES" == "all" ]]; then
            echo "All packages affected"
          else
            echo "Affected packages: $AFFECTED_PACKAGES"
          fi

          # Write to GitHub output without any additional formatting
          {
            echo "affected=$AFFECTED_PACKAGES"
          } >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Check for YAML changes
        id: yaml-changes
        run: |
          echo "::group::YAML Changes Detection"
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA=$(git merge-base ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
            YAML_CHANGED=$(git diff --name-only ${BASE_SHA} | grep -E '\.(yml|yaml)$' || true)
          else
            YAML_CHANGED=$(git diff --name-only HEAD~1 | grep -E '\.(yml|yaml)$' || true)
          fi
          if [[ -n "$YAML_CHANGED" ]]; then
            echo "yaml-changed=true" >> $GITHUB_OUTPUT
            echo "Changed YAML files: $YAML_CHANGED"
          else
            echo "yaml-changed=false" >> $GITHUB_OUTPUT
            echo "No YAML files changed"
          fi
          echo "::endgroup::"

  setup-environment:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          setup-build-cache: true
          setup-test-cache: true

      - name: Generate cache key
        id: cache-key
        run: |
          echo "key=${{ github.sha }}" >> $GITHUB_OUTPUT

  lint:
    name: Lint Code
    needs: [determine-affected, setup-environment]
    runs-on: ubuntu-latest
    if: ${{ needs.determine-affected.outputs.affected != '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          setup-build-cache: true
          setup-test-cache: true
          cache-key: ${{ needs.setup-environment.outputs.cache-key }}

      - name: Run linting
        env:
          ESLINT_FLAGS: v10_config_lookup_from_file
        run: |
          echo "::group::Linting Affected Packages"
          AFFECTED="${{ needs.determine-affected.outputs.affected }}"

          if [[ "$AFFECTED" == "all" ]]; then
            echo "Linting all packages"
            pnpm turbo run lint --concurrency=3 --cache-dir=.turbo
          else
            echo "Linting affected packages: $AFFECTED"
            # Create filter string for affected packages
            FILTER_STRING=""
            IFS=',' read -ra PACKAGES <<< "$AFFECTED"
            for PKG in "${PACKAGES[@]}"; do
              if [[ -n "$PKG" ]]; then
                FILTER_STRING="${FILTER_STRING} --filter=${PKG}"
              fi
            done

            if [[ -n "$FILTER_STRING" ]]; then
              echo "Running: pnpm turbo run lint $FILTER_STRING --concurrency=3 --cache-dir=.turbo"
              pnpm turbo run lint $FILTER_STRING --concurrency=3 --cache-dir=.turbo
            else
              echo "No packages to lint"
            fi
          fi
          echo "::endgroup::"

  type-check:
    name: Type Check
    needs: [determine-affected, setup-environment]
    runs-on: ubuntu-latest
    if: ${{ needs.determine-affected.outputs.affected != '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          setup-build-cache: true
          setup-test-cache: true
          cache-key: ${{ needs.setup-environment.outputs.cache-key }}

      - name: Run type checking
        run: |
          echo "::group::Type Checking Affected Packages"
          AFFECTED="${{ needs.determine-affected.outputs.affected }}"

          if [[ "$AFFECTED" == "all" ]]; then
            echo "Type checking all packages"
            pnpm turbo run type-check --concurrency=3 --cache-dir=.turbo
          else
            echo "Type checking affected packages: $AFFECTED"
            # Create filter string for affected packages
            FILTER_STRING=""
            IFS=',' read -ra PACKAGES <<< "$AFFECTED"
            for PKG in "${PACKAGES[@]}"; do
              if [[ -n "$PKG" ]]; then
                FILTER_STRING="${FILTER_STRING} --filter=${PKG}"
              fi
            done

            if [[ -n "$FILTER_STRING" ]]; then
              echo "Running: pnpm turbo run type-check $FILTER_STRING --concurrency=3 --cache-dir=.turbo"
              pnpm turbo run type-check $FILTER_STRING --concurrency=3 --cache-dir=.turbo
            else
              echo "No packages to type check"
            fi
          fi
          echo "::endgroup::"

  test:
    name: Unit Tests
    needs: [determine-affected, setup-environment]
    runs-on: ubuntu-latest
    if: ${{ needs.determine-affected.outputs.affected != '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          setup-build-cache: true
          setup-test-cache: true
          cache-key: ${{ needs.setup-environment.outputs.cache-key }}

      - name: Run unit tests
        run: |
          echo "::group::Testing Affected Packages"
          AFFECTED="${{ needs.determine-affected.outputs.affected }}"

          if [[ "$AFFECTED" == "all" ]]; then
            echo "Testing all packages"
            pnpm turbo run test --concurrency=3 --cache-dir=.turbo
          else
            echo "Testing affected packages: $AFFECTED"
            # Create filter string for affected packages
            FILTER_STRING=""
            IFS=',' read -ra PACKAGES <<< "$AFFECTED"
            for PKG in "${PACKAGES[@]}"; do
              if [[ -n "$PKG" ]]; then
                FILTER_STRING="${FILTER_STRING} --filter=${PKG}"
              fi
            done

            if [[ -n "$FILTER_STRING" ]]; then
              echo "Running: pnpm turbo run test $FILTER_STRING --concurrency=3 --cache-dir=.turbo"
              pnpm turbo run test $FILTER_STRING --concurrency=3 --cache-dir=.turbo
            else
              echo "No packages to test"
            fi
          fi
          echo "::endgroup::"

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            **/test-results
          retention-days: 7

  yaml-lint:
    name: Lint YAML
    needs: [determine-affected]
    runs-on: ubuntu-latest
    if: ${{ needs.determine-affected.outputs.yaml-changed == 'true' }}
    # This job can run in parallel with other jobs since it doesn't depend on setup
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Python for YAML linting
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install yamllint
        run: |
          python -m pip install --upgrade pip
          pip install yamllint

      - name: Lint YAML files
        run: |
          echo "Linting YAML files..."
          # Lint all YAML files in the .github directory
          yamllint .github/ || exit 1
          # Lint root YAML files if they exist
          if ls *.yml *.yaml 1> /dev/null 2>&1; then
            yamllint *.yml *.yaml || exit 1
          else
            echo "No root YAML files found, skipping..."
          fi

  build:
    name: Build
    needs: [determine-affected, setup-environment, lint, type-check, test]
    runs-on: ubuntu-latest
    if: ${{ needs.determine-affected.outputs.affected != '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup environment
        uses: ./.github/actions/setup
        with:
          setup-build-cache: true
          cache-key: ${{ needs.setup-environment.outputs.cache-key }}
        continue-on-error: false

      # Build only workspace packages (no environment variables needed)
      # Apps will be built by Vercel during deployment with proper env vars
      - name: Build packages only
        run: |
          echo "::group::Building Affected Packages"
          AFFECTED="${{ needs.determine-affected.outputs.affected }}"

          # Core packages that should always be built first if they're affected
          CORE_PACKAGES="@peakhealth/ui @peakhealth/auth-types @peakhealth/auth-utils"

          if [[ "$AFFECTED" == "all" ]]; then
            echo "Building all core packages"
            # Try to build with cache first, fallback to clean build if needed
            pnpm turbo run build \
              --filter="@peakhealth/ui" \
              --filter="@peakhealth/auth-types" \
              --filter="@peakhealth/auth-utils" || {
              echo "Build failed, trying clean build..."
              pnpm turbo run build \
                --filter="@peakhealth/ui" \
                --filter="@peakhealth/auth-types" \
                --filter="@peakhealth/auth-utils" \
                --force
            }
          else
            echo "Building affected packages: $AFFECTED"

            # Create filter string for affected packages
            FILTER_STRING=""
            AFFECTED_CORE=false

            # Check if any core packages are affected
            for CORE_PKG in $CORE_PACKAGES; do
              if [[ "$AFFECTED" == *"$CORE_PKG"* ]]; then
                AFFECTED_CORE=true
                break
              fi
            done

            if [[ "$AFFECTED_CORE" == "true" ]]; then
              echo "Core packages affected, building all core packages"
              # Try to build with cache first, fallback to clean build if needed
              pnpm turbo run build \
                --filter="@peakhealth/ui" \
                --filter="@peakhealth/auth-types" \
                --filter="@peakhealth/auth-utils" || {
                echo "Build failed, trying clean build..."
                pnpm turbo run build \
                  --filter="@peakhealth/ui" \
                  --filter="@peakhealth/auth-types" \
                  --filter="@peakhealth/auth-utils" \
                  --force
              }
            else
              # Build only affected packages
              IFS=',' read -ra PACKAGES <<< "$AFFECTED"
              for PKG in "${PACKAGES[@]}"; do
                if [[ -n "$PKG" ]]; then
                  FILTER_STRING="${FILTER_STRING} --filter=${PKG}"
                fi
              done

              if [[ -n "$FILTER_STRING" ]]; then
                echo "Running: pnpm turbo run build $FILTER_STRING"
                pnpm turbo run build $FILTER_STRING || {
                  echo "Build failed, trying clean build..."
                  pnpm turbo run build $FILTER_STRING --force
                }
              else
                echo "No packages to build"
              fi
            fi
          fi
          echo "::endgroup::"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            packages/*/dist
          retention-days: 1

  # Optional: Full build job for testing (uncomment if needed)
  #  build-apps:
  #    name: Build Apps (Optional)
  #    needs: build
  #    runs-on: ubuntu-latest
  #    if: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
  #    steps:
  #      - name: Checkout repository
  #        uses: actions/checkout@v5
  #
  #      - name: Setup environment
  #        uses: ./.github/actions/setup
  #        with:
  #          setup-build-cache: true
  #
  #      - name: Download package artifacts
  #        uses: actions/download-artifact@v4
  #        with:
  #          name: build-artifacts
  #
  #      # Add environment variables for app builds
  #      - name: Build all apps
  #        env:
  #          # Add your environment variables here
  #          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
  #          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
  #          # Add other required env vars
  #        run: pnpm turbo run build \
  #          --filter="@peakhealth/web" \
  #          --filter="@peakhealth/admin" \
  #          --filter="@peakhealth/landing"
