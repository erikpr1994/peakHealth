/* eslint-disable */
// @ts-nocheck
// This file is generated, do not edit! Run "npx hypertune generate" to regenerate.
// Generated by hypertune-javascript-client v2.7.2

import React from 'react';
import * as hypertune from './hypertune';
import * as sdk from 'hypertune';
import { useRouter } from 'next/navigation';

// Hypertune

export function HypertuneProvider({
  children,
  createSourceOptions,
  dehydratedState,
  rootArgs,
}: {
  children: React.ReactNode;
  createSourceOptions: hypertune.CreateSourceOptions;
  dehydratedState?: hypertune.DehydratedState | null;
  rootArgs: hypertune.RootArgs;
}) {
  return (
    <HypertuneSourceProvider
      createSourceOptions={createSourceOptions}
      dehydratedState={dehydratedState}
    >
      <HypertuneHydrator dehydratedState={dehydratedState}>
        <HypertuneRootProvider rootArgs={rootArgs}>
          {children}
        </HypertuneRootProvider>
      </HypertuneHydrator>
    </HypertuneSourceProvider>
  );
}

// Hypertune Source

const HypertuneSourceContext = React.createContext<{
  hypertuneSource: hypertune.SourceNode;
  setOverride: (newOverride: sdk.DeepPartial<hypertune.Source> | null) => void;
}>({
  hypertuneSource: hypertune.emptySource,
  setOverride: () => {},
});

export function HypertuneSourceProvider({
  children,
  createSourceOptions,
  dehydratedState,
}: {
  children: React.ReactNode;
  createSourceOptions: hypertune.CreateSourceOptions;
  dehydratedState?: hypertune.DehydratedState | null;
}) {
  const hypertuneSource = hypertune.createSource({
    ...createSourceOptions,
  });

  const router = useRouter();

  // We need to keep track of the state hash to force a re-render when the state changes
  // This is because the hypertuneSource object itself doesn't change, only its internal state
  const [stateHash, setStateHash] = React.useState(
    hypertuneSource.getStateHash()
  );

  // Listen for state changes and update the state hash
  React.useEffect(() => {
    const updateListener = () => {
      setStateHash(hypertuneSource.getStateHash());
    };

    hypertuneSource.addUpdateListener(updateListener);
    return () => {
      hypertuneSource.removeUpdateListener(updateListener);
    };
  }, [hypertuneSource, router]);

  const hypertuneSourceForStateHash = React.useMemo(() => {
    const { context } = hypertuneSource.props;
    const newProps = {
      ...hypertuneSource.props,
      context,
    };
    return new hypertune.SourceNode(newProps);
  }, [hypertuneSource, stateHash]);

  const [override, setOverrideState] = React.useState<sdk.DeepPartial<hypertune.Source> | null>(null);
  const setOverride = React.useCallback(
    (newOverride: sdk.DeepPartial<hypertune.Source> | null) => {
      setOverrideState(newOverride);
      hypertuneSource.setOverride(newOverride);
    },
    [hypertuneSource]
  );

  const value = React.useMemo(
    () => ({ hypertuneSource: hypertuneSourceForStateHash, setOverride }),
    [hypertuneSourceForStateHash, setOverride]
  );

  return (
    <HypertuneSourceContext.Provider value={value}>
      {children}
    </HypertuneSourceContext.Provider>
  );
}

export function useHypertuneSource(): hypertune.SourceNode {
  const { hypertuneSource } = React.useContext(HypertuneSourceContext);
  return hypertuneSource;
}

export function useHypertuneSetOverride(): (
  newOverride: sdk.DeepPartial<hypertune.Source> | null
) => void {
  const { setOverride } = React.useContext(HypertuneSourceContext);
  return setOverride;
}

// Hypertune Root

const HypertuneRootContext = React.createContext(
  new hypertune.RootNode({
    context: null,
    source: null,
    args: {
      context: {
        environment: 'development',
        user: {
          id: '0',
          email: 'admin@example.com',
        },
      },
    },
  })
);

export function HypertuneRootProvider({
  children,
  rootArgs,
}: {
  children: React.ReactNode;
  rootArgs: hypertune.RootArgs;
}) {
  const hypertuneSource = useHypertuneSource();

  const hypertuneRoot = hypertuneSource.root({ args: rootArgs });

  return (
    <HypertuneRootContext.Provider value={hypertuneRoot}>
      {children}
    </HypertuneRootContext.Provider>
  );
}

export function useHypertune(): hypertune.RootNode {
  const hypertuneRoot = React.useContext(HypertuneRootContext);

  if (!hypertuneRoot.props.context) {
    console.warn(
      '[Hypertune] Calling `useHypertune` hook outside of the `HypertuneProvider`. Fallback values will be used.'
    );
  }

  return hypertuneRoot;
}

export function HypertuneHydrator({
  children,
  dehydratedState,
  rootArgs,
}: {
  children?: React.ReactNode;
  dehydratedState?: hypertune.DehydratedState | null;
  rootArgs?: hypertune.RootArgs;
}) {
  const hypertuneSource = useHypertuneSource();

  React.useEffect(() => {
    hypertuneSource.hydrate(dehydratedState);
  }, [hypertuneSource, dehydratedState]);

  if (!children) {
    return (
      <HypertuneRootProvider rootArgs={rootArgs}>
        <></>
      </HypertuneRootProvider>
    );
  }

  return <>{children}</>;
}

// Client-side logging

export function HypertuneClientLogger({
  children,
  flagPaths,
}: {
  children?: React.ReactNode;
  flagPaths: hypertune.FlagPaths[];
}) {
  const hypertuneRoot = useHypertune();
  const isReady = hypertuneRoot.isReady();

  React.useEffect(() => {
    if (!isReady) {
      return;
    }

    // Log flag values
    hypertuneRoot.getFlagValues({
      flagFallbacks: hypertune.flagFallbacks,
      flagPaths,
    });
  }, [hypertuneRoot, isReady, flagPaths]);

  return <>{children}</>;
}

// Cookie override

export function setCookieOverride(
  newOverride: sdk.DeepPartial<hypertune.Source> | null
): void {
  if (newOverride === null) {
    document.cookie = `${hypertune.overrideCookieName}=;max-age=0;path=/`;
    return;
  }

  const expires = 'max-age=31536000'; // 1 year
  document.cookie = `${hypertune.overrideCookieName}=${JSON.stringify(newOverride)};${expires};path=/`;
}

